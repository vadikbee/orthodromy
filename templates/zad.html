<!DOCTYPE html>
<html lang="ru">
<head>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–û—Ä—Ç–æ–¥—Ä–æ–º–∏—è</title>


    <style>
        body {
            text-align: center;
            font-family: Arial, sans-serif;
            background-image: url('https://avatars.mds.yandex.net/i?id=50a1c8ff239e57b2decd55aee538c13c5fe6d86b-7754220-images-thumbs&n=13');
            background-size: cover;
            background-position: center;
            color: black;
            padding: 20px;
        }

        #map {
            width: 1000px; /* –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —à–∏—Ä–∏–Ω–∞ –∫–∞—Ä—Ç—ã */
            height: 700px; /* –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤—ã—Å–æ—Ç–∞ –∫–∞—Ä—Ç—ã */
            margin: 20px auto; /* –¶–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–∞—Ä—Ç—ã */
            border: 10px solid rgba(0, 0, 0, 0.5); /* –ì—Ä–∞–Ω–∏—Ü–∞ –∫–∞—Ä—Ç—ã */
            box-sizing: border-box; /* –£—á–∏—Ç—ã–≤–∞–µ–º –≥—Ä–∞–Ω–∏—Ü—ã –∏ –æ—Ç—Å—Ç—É–ø—ã */
        }



        form {
            display: inline-block;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.4);
            padding: 10px 20px;
            border-radius: 10px;
            max-width: 600px; /* –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —à–∏—Ä–∏–Ω—É —Ñ–æ—Ä–º—ã */
        }

        input {
            display: block;
            margin: 10px auto;
            width: 100%;
            padding: 5px;
            text-align: center;
            width: 90%; /* –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —à–∏—Ä–∏–Ω—É –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö */
        }

        label {
            font-weight: bold;
            margin-top: 10px;
        }

        .buttons {
            display: flex;
            justify-content: space-between;

            margin-top: 10px;
            flex-wrap: wrap; /* –ö–Ω–æ–ø–∫–∏ –±—É–¥—É—Ç —Ä–∞—Å–ø–æ–ª–∞–≥–∞—Ç—å—Å—è –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏ –Ω–∞ –º–∞–ª–µ–Ω—å–∫–∏—Ö —ç–∫—Ä–∞–Ω–∞—Ö */
        }

        button {
            width: 48%; /* –£–º–µ–Ω—å—à–∞–µ–º –∫–Ω–æ–ø–∫–∏ –¥–ª—è –∫–æ–º–ø–∞–∫—Ç–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è */
            padding: 15px 20px;
            background-color: #4CAF50;

            color: white;
            border: none;
            cursor: pointer;
            margin-left: 10px;
            margin-top: 10px;
        }

        }


        .krivaya {
            font-size: 20px;
            color: black;
            padding: 10px 20px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .krivaya span {
        font-size: 20px;
        margin-bottom: 10px;
        font-weight: bold;
        }
        .krivaya2 span {
        font-size: 20px;
        margin-bottom: 10px;
        font-weight: bold;
        }

        #krivaya-text, #krivaya2-text {
        margin-bottom: 20px;
        }


         /* –°—Ç–∏–ª–∏ –¥–ª—è –∫–Ω–æ–ø–∫–∏ –ø–µ—Ä–µ—Ö–æ–¥–∞ –Ω–∞ –∫–∞—Ä—Ç—É –¥–ª—è WKT */
        .back-button {
           background-color: black;
            border: none;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: block;
            font-size: 16px;
            margin: 10px auto;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s;
            position: absolute;
            position: fixed;
            top: 50px;
            left: 30px;
            width: auto; /* –£–º–µ–Ω—å—à–∞–µ–º –∫–Ω–æ–ø–∫–∏ –¥–ª—è –∫–æ–º–ø–∞–∫—Ç–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è */
        }

        .dowlad-button {
            background-color: black;
            border: none;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: block;
            font-size: 16px;
            margin: 10px auto;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s;
            position: absolute;
            position: fixed;
            top: 100px;
            left: 30px;

            width: auto; /* –£–º–µ–Ω—å—à–∞–µ–º –∫–Ω–æ–ø–∫–∏ –¥–ª—è –∫–æ–º–ø–∞–∫—Ç–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è */
        }


        #bespilot-text {

         font-size: 18px;
         display: inline-block;  /* –ß—Ç–æ–±—ã —Ç–µ–∫—Å—Ç –Ω–µ –∑–∞–Ω–∏–º–∞–ª –≤—Å—é —à–∏—Ä–∏–Ω—É –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ */
         background-color: rgba(255, 255, 255, 0.7);  /* –ë–µ–ª—ã–π —Ñ–æ–Ω —Å 70% –Ω–µ–ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏ */
         padding: 10px 20px;  /* –û—Ç—Å—Ç—É–ø—ã –≤–Ω—É—Ç—Ä–∏ –±–ª–æ–∫–∞ */
         border-radius: 8px;  /* –û–∫—Ä—É–≥–ª–µ–Ω–Ω—ã–µ —É–≥–ª—ã */
         color: black;  /* –¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞ */
         margin-bottom: 10px;  /* –û—Ç—Å—Ç—É–ø —Å–Ω–∏–∑—É (–Ω–∞–ø—Ä–∏–º–µ—Ä, 20px) */
         font-weight: bold;
        }
        .send-button {
        background-color: white;
        color: black;
        padding: 10px 20px;
        text-align: center;
        text-decoration: none;
        display: block;
        font-size: 16px;
        margin: 10px auto;
        cursor: pointer;
        border-radius: 5px;
        transition: background-color 0.3s;
        border: 2px solid black;  /* –ß–µ—Ä–Ω–∞—è —Ä–∞–º–∫–∞ */
        }


    .button:hover, .back-button:hover, .dowlad-button:hover, .send-button:hover, .knopki-meny:hover  {
            background-color: rgba(0, 0, 0, 0.5);
        }


    </style>
    <script src="https://api-maps.yandex.ru/2.1/?lang=ru_RU" type="text/javascript"></script>
</head>

<body>
    <h1>–û—Ä—Ç–æ–¥—Ä–æ–º–∏—è</h1>
    <div id="krivaya-text" class="krivaya"><label> <span style="color: blue;">–°–∏–Ω—è—è</span> <span style="color: black;">–ª–∏–Ω–∏—è - –ø—Ä—è–º–∞—è </span> </label></div>
    <div id="krivaya2-text" class="krivaya2"><label><span style="color: rgb(155, 16, 17);">–ë–æ—Ä–¥–æ–≤–∞—è</span> <span style="color: black;">–ª–∏–Ω–∏—è - –∫—Ä–∏–≤–∞—è </span> </label></div>

    <form id="form">
        <label>–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –Ω–∞—á–∞–ª—å–Ω–æ–π —Ç–æ—á–∫–∏ (—à–∏—Ä–æ—Ç–∞, –¥–æ–ª–≥–æ—Ç–∞):<br>
        55.861090, 37.625316 (–ú–æ—Å–∫–≤–∞)</label>
        <input type="text" id="start_point" placeholder="–ù–∞–ø—Ä–∏–º–µ—Ä, 37.625316, 55.861090"><br>

        <label>–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∫–æ–Ω–µ—á–Ω–æ–π —Ç–æ—á–∫–∏ (—à–∏—Ä–æ—Ç–∞, –¥–æ–ª–≥–æ—Ç–∞):<br>
        53.902735, 27.555691 (–ë–µ–ª–∞—Ä—É—Å—å)</label>
        <input type="text" id="end_point" placeholder="–ù–∞–ø—Ä–∏–º–µ—Ä, 27.555691, 53.902735"><br>

        <label>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–∑–ª–æ–≤:</label>
        <input type="number" id="num_nodes" value="20"><br>

         <div id="bespilot-text"><label>–°–∫–æ—Ä–æ—Å—Ç—å –∏ –≤—ã—Å–æ—Ç–∞ –ø–æ–ª–µ—Ç–∞ –±–µ—Å–ø–∏–ª–æ—Ç–Ω–∏–∫–∞</label></div>
        <div class="form-right">
        <label>–°–∫–æ—Ä–æ—Å—Ç—å (–º/—Å):</label>
        <input type="number" id="speed" placeholder="–í–≤–µ–¥–∏—Ç–µ —Å–∫–æ—Ä–æ—Å—Ç—å –≤ –º/—Å" min="0" step="0.1"><br>

        <label>–í—ã—Å–æ—Ç–∞ (–º):</label>
        <input type="number" id="altitude" placeholder="–í–≤–µ–¥–∏—Ç–µ –≤—ã—Å–æ—Ç—É –≤ –º–µ—Ç—Ä–∞—Ö" min="0" step="1"><br>
        </div>

        <div class="buttons">
            <button type="submit" id="postroit" class="knopki-meny">–ü–æ—Å—Ç—Ä–æ–∏—Ç—å –æ—Ä—Ç–æ–¥—Ä–æ–º–∏—é</button>
            <button type="button" id="toggle-curve" class="knopki-meny">–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –Ω–∞ –∫—Ä–∏–≤—É—é/–ø—Ä—è–º—É—é –ª–∏–Ω–∏—é</button>
            <button type="button" id="reset" class="knopki-meny">–°–±—Ä–æ—Å–∏—Ç—å</button>
            <button type="button" id="downloadButton" class="dowlad-button">–°–∫–∞—á–∞—Ç—å –º–∞—Ä—à—Ä—É—Ç (KMZ)</button>
            <button onclick="disableAlerts(); buildRoute(); window.location.href='/elevation-map'" class="back-button">–ü–µ—Ä–µ–π—Ç–∏ –Ω–∞ –∫–∞—Ä—Ç—É –¥–ª—è WKT</button>
            <button type="button" id="start-drawing" class="knopki-meny">–ù–∞—á–∞—Ç—å/–ó–∞–∫–æ–Ω—á–∏—Ç—å —Ä–∏—Å–æ–≤–∞—Ç—å –∑–æ–Ω—É –∑–∞–ø—Ä–µ—Ç–∞ –ø–æ–ª–µ—Ç–æ–≤</button>
            <button type="button" id="build-restricted-area" class="knopki-meny">–ü–æ—Å—Ç—Ä–æ–∏—Ç—å –∑–∞–ø—Ä–µ—Ç–Ω—É—é –∑–æ–Ω—É</button>
            <button type="button" id="orta-zapret" class="knopki-meny">–û—Ä—Ç–æ–¥—Ä–æ–º–∏—è —Å –∑–æ–Ω–∞–º–∏ –∑–∞–ø—Ä–µ—Ç–∞ <br> (–∫–∞–∂–¥–æ–µ –Ω–∞–∂–∞—Ç–∏–µ - –ø–µ—Ä–µ—Å—Ç—Ä–æ–µ–Ω–∏–µ)</button>
            <button type="button" id="sendToDrone" class="send-button">–û—Ç–ø—Ä–∞–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –Ω–∞ –±–µ—Å–ø–∏–ª–æ—Ç–Ω–∏–∫</button>
            <button type="button" id="connectDrone" class="send-button">–ü–æ–¥–∫–ª—é—á–∏—Ç—å –±–µ—Å–ø–∏–ª–æ—Ç–Ω–∏–∫</button>

        </div>
    </form>


    <div id="map"></div>
    <script>
// —Ä–∞–±–æ—Ç–∞ —Å –∫–∞—Ä—Ç–æ–π
ymaps.ready(init); // –î–æ–∂–∏–¥–∞–µ–º—Å—è –∑–∞–≥—Ä—É–∑–∫–∏ API –Ø–Ω–¥–µ–∫—Å.–ö–∞—Ä—Ç
var myMap, isOrthodrome = true, coords;
var startMarker, endMarker;
var restrictedAreas = []; // –ú–∞—Å—Å–∏–≤ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∑–æ–Ω –∑–∞–ø—Ä–µ—Ç–∞
var drawingMode = false; // –†–µ–∂–∏–º —Ä–∏—Å–æ–≤–∞–Ω–∏—è
var points = []; // –ú–∞—Å—Å–∏–≤ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö —Ç–æ—á–µ–∫
var routes = []; // –ú–∞—Å—Å–∏–≤ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –º–∞—Ä—à—Ä—É—Ç–æ–≤
var intersectionLine = null; // –ì–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è –ª–∏–Ω–∏–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
var intersectionLines = []; // –ú–∞—Å—Å–∏–≤ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –≤—Å–µ—Ö –ª–∏–Ω–∏–π –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è

function init() { //–¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –≤—Å–µ–≥–¥–∞ —Ç—É—Ç
    myMap = new ymaps.Map("map", {
        center: [55.76, 37.64],
        zoom: 10
    });
    //console.log("–ö–∞—Ä—Ç–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞:", myMap);


/////////////////////////////////////—Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è –æ–±—Ö–æ–¥–∞/////////////////////////////////////

   /* // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è Catmull-Rom —Å–ø–ª–∞–π–Ω–∞
    function catmullRomSpline(points, numSegments = 100) {
        const splinePoints = [];

        for (let i = 0; i < points.length - 1; i++) {
            const p0 = points[Math.max(i - 1, 0)];
            const p1 = points[i];
            const p2 = points[i + 1];
            const p3 = points[Math.min(i + 2, points.length - 1)];

            for (let t = 0; t <= 1; t += 1 / numSegments) {
                const t2 = t * t;
                const t3 = t2 * t;

                const x = 0.5 * ((-p0[0] + 3 * p1[0] - 3 * p2[0] + p3[0]) * t3
                    + (2 * p0[0] - 5 * p1[0] + 4 * p2[0] - p3[0]) * t2
                    + (-p0[0] + p2[0]) * t
                    + 2 * p1[0]);

                const y = 0.5 * ((-p0[1] + 3 * p1[1] - 3 * p2[1] + p3[1]) * t3
                    + (2 * p0[1] - 5 * p1[1] + 4 * p2[1] - p3[1]) * t2
                    + (-p0[1] + p2[1]) * t
                    + 2 * p1[1]);

                splinePoints.push([x, y]);
            }
        }

        return splinePoints;
    } */

    // –§—É–Ω–∫—Ü–∏—è –ª–∏–Ω–µ–π–Ω–æ–π –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–∏ –º–µ–∂–¥—É –¥–≤—É–º—è —Ç–æ—á–∫–∞–º–∏
    function interpolatePoints(p1, p2, numPoints) {
        const interpolated = [];
        for (let i = 0; i <= numPoints; i++) {
            const t = i / numPoints;
            const x = p1[0] + t * (p2[0] - p1[0]);
            const y = p1[1] + t * (p2[1] - p1[1]);
            interpolated.push([x, y]);
        }
        return interpolated;
    }

    // –§—É–Ω–∫—Ü–∏—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ç–æ—á–µ–∫ –¥–ª—è –≤—Å–µ–π –ª–∏–Ω–∏–∏
    function smoothRoute(routeCoords, numSegments = 10) {
        const smoothCoords = [];
        for (let i = 0; i < routeCoords.length - 1; i++) {
            smoothCoords.push(...interpolatePoints(routeCoords[i], routeCoords[i + 1], numSegments));
        }
        return smoothCoords;
    }
/////////////////////////////////////—Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è –ª–∏–Ω–∏–∏ –æ–±—Ö–æ–¥–∞ /////////////////////////////////////



         // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–π –ø–æ–¥—Å—Ç—Ä–æ–π–∫–∏ –∫–∞—Ä—Ç—ã
    function adjustMapSize() {
        const mapContainer = document.getElementById('map');
        const windowHeight = window.innerHeight;

        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã—Å–æ—Ç—É –∫–∞—Ä—Ç—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤—ã—Å–æ—Ç—ã –æ–∫–Ω–∞
        mapContainer.style.height = `${Math.min(0.7 * windowHeight, 900)}px`; // 70% –æ—Ç –≤—ã—Å–æ—Ç—ã –æ–∫–Ω–∞, –Ω–æ –Ω–µ –±–æ–ª—å—à–µ 900px

        // –û–±–Ω–æ–≤–ª—è–µ–º —Ä–∞–∑–º–µ—Ä—ã –∫–∞—Ä—Ç—ã –≤ –Ø–Ω–¥–µ–∫—Å API
        if (myMap) {
            myMap.container.fitToViewport();
        }
    }

    // –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–∞–∑–º–µ—Ä–æ–≤ –æ–∫–Ω–∞
    window.addEventListener('load', adjustMapSize);
    window.addEventListener('resize', adjustMapSize);



    myMap.events.add('click', function (e) {
        var coords = e.get('coords');
        if (drawingMode) {
            addPoint(coords);
        } else {
            if (!startMarker) {
                addStartMarker(coords);
            } else if (!endMarker) {
                addEndMarker(coords);
            } else {
                alert("–£–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –æ–±–µ —Ç–æ—á–∫–∏. –°–±—Ä–æ—Å—å—Ç–µ, —á—Ç–æ–±—ã —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –Ω–æ–≤—ã–µ.");
            }
        }
    });

    document.getElementById('form').addEventListener('submit', function (event) {
        event.preventDefault();
        buildRoute();
    });

    document.getElementById('toggle-curve').addEventListener('click', function () {
    isOrthodrome = !isOrthodrome;
    removeIntersectionLines(); // –û—á–∏—â–∞–µ–º –≤—Å–µ –ª–∏–Ω–∏–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –ø—Ä–∏ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–∏
    buildRoute();
});


    document.getElementById('reset').addEventListener('click', function () {
        resetMap();
    });

    document.getElementById('start-drawing').addEventListener('click', function () {
        toggleDrawingMode();
    });

    document.getElementById('build-restricted-area').addEventListener('click', function () {
        buildRestrictedArea();
    });
}


//////////////////////////–ª–æ–≥–∏–∫–∞ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –æ–±—Ö–æ–¥–Ω–æ–≥–æ –ø—É—Ç–∏ /////////////////////////////////////////////////

document.getElementById('orta-zapret').addEventListener('click', async function () {
    if (!restrictedAreas.length || !routes.length) {
        alert("–°–Ω–∞—á–∞–ª–∞ –ø–æ—Å—Ç—Ä–æ–π—Ç–µ –º–∞—Ä—à—Ä—É—Ç –∏ –∑–∞–¥–∞–π—Ç–µ –∑–æ–Ω—ã –∑–∞–ø—Ä–µ—Ç–∞.");
        return;
    }

    removeIntersectionLines();

    const routeCoords = routes[0].geometry.getCoordinates();
    if (routeCoords.length < 2) {
        alert("–ú–∞—Ä—à—Ä—É—Ç –¥–æ–ª–∂–µ–Ω —Å–æ—Å—Ç–æ—è—Ç—å –∫–∞–∫ –º–∏–Ω–∏–º—É–º –∏–∑ –¥–≤—É—Ö —Ç–æ—á–µ–∫.");
        return;
    }

    await buildRouteAvoidingZones(routeCoords, restrictedAreas);
});

// –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –º–∞—Ä—à—Ä—É—Ç–∞ –≤ –æ–±—Ö–æ–¥ –∑–æ–Ω –∑–∞–ø—Ä–µ—Ç–∞
async function buildRouteAvoidingZones(routeCoords, zones) {
    const [startPoint, endPoint] = [routeCoords[0], routeCoords.at(-1)];
    const restrictedAreas = zones.map(zone => zone.geometry.getCoordinates()[0]);

   // console.log('Start:', startPoint, 'End:', endPoint, 'Restricted Areas:', restrictedAreas);

    try {
        let attempts = 0;
        let maxAttempts = 5;
        let isIntersectingRestrictedArea = true;
        let data;

        while (isIntersectingRestrictedArea && attempts < maxAttempts) {
            const response = await fetch('/orthodrome_with_restrictions', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ start_point: startPoint, end_point: endPoint, restricted_areas: restrictedAreas })
            });
            data = await response.json();

          //  console.log('Response data:', data);

            if (data.coordinates?.length > 2) {
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ —Å –∑–∞–ø—Ä–µ—Ç–Ω—ã–º–∏ –∑–æ–Ω–∞–º–∏
                isIntersectingRestrictedArea = restrictedAreas.some(area => {
                    return data.coordinates.some((coord, index) => {
                        if (index === data.coordinates.length - 1) return false;
                        const segment = [coord, data.coordinates[index + 1]];
                        return isSegmentIntersectingPolygon(segment, area);
                    });
                });

                if (isIntersectingRestrictedArea) {
                 //   console.log(`–ü–æ–ø—ã—Ç–∫–∞ ${attempts + 1}: –ú–∞—Ä—à—Ä—É—Ç –≤—Å—ë –µ—â—ë –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç –∑–∞–ø—Ä–µ—Ç–Ω—ã–µ –∑–æ–Ω—ã, –ø–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º...`);
                    attempts++;
                }
            } else {
                alert("–ú–∞—Ä—à—Ä—É—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω, –≤–æ–∑–º–æ–∂–Ω–æ, —Å–ª–∏—à–∫–æ–º —Å–∏–ª—å–Ω—ã–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è.");
                return;
            }
        }

        if (isIntersectingRestrictedArea) {
            alert("–ú–∞—Ä—à—Ä—É—Ç –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ—Å—Ç—Ä–æ–∏—Ç—å, –≤—Å–µ –ø—É—Ç–∏ –ø–µ—Ä–µ—Å–µ–∫–∞—é—Ç –∑–∞–ø—Ä–µ—Ç–Ω—ã–µ –∑–æ–Ω—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∏–∑–º–µ–Ω–∏—Ç—å –∑–æ–Ω—ã –∏–ª–∏ –∫–æ–Ω–µ—á–Ω—ã–µ —Ç–æ—á–∫–∏.");
        } else {
            drawNewRoute(data.coordinates, endPoint);
        }
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞:', error);
        alert('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–∏ –º–∞—Ä—à—Ä—É—Ç–∞.');
    }
}



// –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –Ω–æ–≤–æ–≥–æ –º–∞—Ä—à—Ä—É—Ç–∞ —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –Ω–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ –∫–æ–Ω–µ—á–Ω–æ–π —Ç–æ—á–∫–∏
function drawNewRoute(routeCoords, endPoint) {
    removeRoutes();

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ —Å –∑–∞–ø—Ä–µ—Ç–Ω—ã–º–∏ –∑–æ–Ω–∞–º–∏
    let isIntersectingRestrictedArea = restrictedAreas.some(area => {
        const areaCoords = area.geometry.getCoordinates()[0];
        return routeCoords.some((coord, index) => {
            if (index === routeCoords.length - 1) return false;
            const segment = [coord, routeCoords[index + 1]];
            return isSegmentIntersectingPolygon(segment, areaCoords);
        });
    });

    // –ï—Å–ª–∏ –º–∞—Ä—à—Ä—É—Ç –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç –∑–∞–ø—Ä–µ—Ç–Ω—ã–µ –∑–æ–Ω—ã, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ–ø–æ–≤–µ—â–µ–Ω–∏–µ –∏ –ø–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –º–∞—Ä—à—Ä—É—Ç
    if (isIntersectingRestrictedArea) {
        alert("–ú–∞—Ä—à—Ä—É—Ç –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç –∑–∞–ø—Ä–µ—Ç–Ω—É—é –∑–æ–Ω—É! –ü–µ—Ä–µ—Å—Ç—Ä–æ–µ–Ω–∏–µ –º–∞—Ä—à—Ä—É—Ç–∞...");
        buildRouteAvoidingZones(routeCoords, restrictedAreas);
        return;
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞, –º–æ–∂–µ—Ç –ª–∏ –º–∞—Ä—à—Ä—É—Ç –¥–æ—Å—Ç–∏—á—å –∫–æ–Ω–µ—á–Ω–æ–π —Ç–æ—á–∫–∏
    if (calculateDistance(routeCoords.at(-1), endPoint) > 500) {
        alert("–ú–∞—Ä—à—Ä—É—Ç –Ω–µ –º–æ–∂–µ—Ç –¥–æ—Å—Ç–∏—á—å –∫–æ–Ω–µ—á–Ω–æ–π —Ç–æ—á–∫–∏. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∑–æ–Ω—ã –∑–∞–ø—Ä–µ—Ç–∞.");
        return;
    }

    // –ï—Å–ª–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π –Ω–µ—Ç, –æ—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –º–∞—Ä—à—Ä—É—Ç
    const newRouteLine = new ymaps.Polyline(routeCoords, {
        balloonContent: '–ú–∞—Ä—à—Ä—É—Ç –≤ –æ–±—Ö–æ–¥ –∑–æ–Ω –∑–∞–ø—Ä–µ—Ç–∞'
    }, {
        strokeColor: 'rgb(34, 139, 34)',
        strokeWidth: 4
    });

    myMap.geoObjects.add(newRouteLine);
    routes.push(newRouteLine);
    myMap.setBounds(newRouteLine.geometry.getBounds());
}


// –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –º–µ–∂–¥—É —Ç–æ—á–∫–∞–º–∏
function calculateDistance([x1, y1], [x2, y2]) {
    const R = 6371e3; // —Ä–∞–¥–∏—É—Å –ó–µ–º–ª–∏ –≤ –º–µ—Ç—Ä–∞—Ö
    const toRad = Math.PI / 180;
    const œÜ1 = y1 * toRad, œÜ2 = y2 * toRad, ŒîœÜ = (y2 - y1) * toRad, ŒîŒª = (x2 - x1) * toRad;

    const a = Math.sin(ŒîœÜ / 2) ** 2 + Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) ** 2;
    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
///////////////.....////////// —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∑–∞–≤–∏—Å—à–∏—Ö –∫–Ω–æ–ø–æ–∫ //////////.....///////////////

document.addEventListener("DOMContentLoaded", function() {
    console.log("DOM –∑–∞–≥—Ä—É–∂–µ–Ω, –∏—Å–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–≤–∏—Å—à–∏–µ –∫–Ω–æ–ø–∫–∏...");

    // üîπ –°–ø–∏—Å–æ–∫ ID –∫–Ω–æ–ø–æ–∫, –∫–æ—Ç–æ—Ä—ã–µ –∑–∞–≤–∏—Å–∞—é—Ç (–¥–æ–±–∞–≤–ª—è–π—Ç–µ —Å—é–¥–∞ –Ω—É–∂–Ω—ã–µ –∫–Ω–æ–ø–∫–∏)
    let laggingButtons = ["connectDrone", "sendToDrone"];

    laggingButtons.forEach(buttonId => {
        let button = document.getElementById(buttonId);
        if (!button) {
            console.warn(`–ö–Ω–æ–ø–∫–∞ —Å ID="${buttonId}" –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.`);
            return;
        }

        let newButton = button.cloneNode(true);  // –ö–ª–æ–Ω–∏—Ä—É–µ–º –∫–Ω–æ–ø–∫—É
        button.replaceWith(newButton); // –ó–∞–º–µ–Ω—è–µ–º —Å—Ç–∞—Ä—É—é –∫–Ω–æ–ø–∫—É –Ω–∞ –Ω–æ–≤—É—é

        console.log(`–ö–Ω–æ–ø–∫–∞ —Å ID="${newButton.id}" –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∞!`);

        // üîπ –ù–∞–∑–Ω–∞—á–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –ø–æ ID –∫–Ω–æ–ø–∫–∏
        if (newButton.id === "connectDrone") {
            newButton.addEventListener('click', function() {
                console.log("–ö–Ω–æ–ø–∫–∞ '–ü–æ–¥–∫–ª—é—á–∏—Ç—å –±–µ—Å–ø–∏–ª–æ—Ç–Ω–∏–∫' —Ä–∞–±–æ—Ç–∞–µ—Ç!");
                fetch('/connect_drone', { method: 'POST' })
                    .then(response => response.json())
                    .then(data => {
                        console.log("–û—Ç–≤–µ—Ç —Å–µ—Ä–≤–µ—Ä–∞:", data);
                        alert(data.connected ? "–ë–µ—Å–ø–∏–ª–æ—Ç–Ω–∏–∫ –ø–æ–¥–∫–ª—é—á–µ–Ω!" : "–ë–µ—Å–ø–∏–ª–æ—Ç–Ω–∏–∫ –Ω–µ –ø–æ–¥–∫–ª—é—á–µ–Ω.");
                    })
                    .catch(error => {
                        console.error("–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞:", error);
                        alert("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏.");
                    });
            });
        }

        // üîπ –ü—Ä–∏–º–µ—Ä –¥–ª—è –¥—Ä—É–≥–æ–π –∫–Ω–æ–ø–∫–∏
        else if (newButton.id === "sendToDrone") {
            newButton.addEventListener('click', function() {
                console.log("–∫–Ω–æ–ø–∫–∞ (–æ—Ç–ø—Ä–∞–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ) –Ω–∞–∂–∞—Ç–∞!");
            });
        }

        console.log(`–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞–∑–Ω–∞—á–µ–Ω –¥–ª—è –∫–Ω–æ–ø–∫–∏ —Å ID="${newButton.id}"`);
    });

    console.log("–í—Å–µ –∑–∞–≤–∏—Å—à–∏–µ –∫–Ω–æ–ø–∫–∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω—ã!");
});

///////////////.....////////// —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∑–∞–≤–∏—Å—à–∏—Ö –∫–Ω–æ–ø–æ–∫ //////////.....///////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function disableAlerts() { //–≤—ã–∫–ª—é—á–∞—é —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –Ω–∞ –∫–Ω–æ–ø–∫—É
            // –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ–º —Ñ—É–Ω–∫—Ü–∏—é alert
            window.alert = function() {};
    }

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –ª–∏–Ω–∏–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
function removeIntersectionLines() {
    intersectionLines.forEach(line => {
        myMap.geoObjects.remove(line);
    });
    intersectionLines = []; // –û—á–∏—â–∞–µ–º –º–∞—Å—Å–∏–≤ –ª–∏–Ω–∏–π –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
}


function addStartMarker(coords) {
    if (startMarker) {
        myMap.geoObjects.remove(startMarker);
    }

    startMarker = new ymaps.Placemark(coords, {
        balloonContent: '–ù–∞—á–∞–ª—å–Ω–∞—è —Ç–æ—á–∫–∞: ' + coords[1].toFixed(6) + ', ' + coords[0].toFixed(6)
    }, {
        preset: 'islands#icon',
        iconColor: '#0095b6'
    });

    myMap.geoObjects.add(startMarker);
    document.getElementById('start_point').value = coords[0].toFixed(6) + ', ' + coords[1].toFixed(6);
}

function addEndMarker(coords) {
    if (endMarker) {
        myMap.geoObjects.remove(endMarker);
    }

    endMarker = new ymaps.Placemark(coords, {
        balloonContent: '–ö–æ–Ω–µ—á–Ω–∞—è —Ç–æ—á–∫–∞: ' + coords[1].toFixed(6) + ', ' + coords[0].toFixed(6)
    }, {
        preset: 'islands#icon',
        iconColor: '#ff0000'
    });

    myMap.geoObjects.add(endMarker);
    document.getElementById('end_point').value = coords[0].toFixed(6) + ', ' + coords[1].toFixed(6);
}

function addPoint(coords) {
    points.push(coords); // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤—ã–±—Ä–∞–Ω–Ω–æ–π —Ç–æ—á–∫–∏

    var pointMarker = new ymaps.Placemark(coords, {
        balloonContent: '–¢–æ—á–∫–∞ ' + points.length + ': ' + coords[1].toFixed(6) + ', ' + coords[0].toFixed(6)
    }, {
        preset: 'islands#icon',
        iconColor: '#FFFF00' // –¶–≤–µ—Ç –º–∞—Ä–∫–µ—Ä–∞
    });

    myMap.geoObjects.add(pointMarker);
}

function toggleDrawingMode() {
    drawingMode = !drawingMode; // –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º —Ä–µ–∂–∏–º —Ä–∏—Å–æ–≤–∞–Ω–∏—è
    points = []; // –û—á–∏—â–∞–µ–º –º–∞—Å—Å–∏–≤ —Ç–æ—á–µ–∫
    if (!drawingMode) {
        // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –º–∞—Ä–∫–µ—Ä—ã —Å—Ç–∞—Ä—Ç–æ–≤–æ–π –∏ –∫–æ–Ω–µ—á–Ω–æ–π —Ç–æ—á–∫–∏, –µ—Å–ª–∏ –æ–Ω–∏ –±—ã–ª–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã
        if (startMarker) myMap.geoObjects.add(startMarker);
        if (endMarker) myMap.geoObjects.add(endMarker);
    }
}

function buildRestrictedArea() {
    if (points.length > 2) {
        // –°–æ–∑–¥–∞–µ–º –º–Ω–æ–≥–æ—É–≥–æ–ª—å–Ω–∏–∫
        var restrictedAreaPolygon = new ymaps.Polygon([points], {
            balloonContent: '–ó–∞–ø—Ä–µ—Ç–Ω–∞—è –∑–æ–Ω–∞'
        }, {
            fillColor: 'rgba(0, 0, 255, 0.3)', // –°–∏–Ω–∏–π —Ü–≤–µ—Ç —Å –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å—é
            strokeColor: '#0000FF',
            strokeWidth: 2
        });

        myMap.geoObjects.add(restrictedAreaPolygon);

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–ª–∏–≥–æ–Ω –≤ –º–∞—Å—Å–∏–≤
        restrictedAreas.push(restrictedAreaPolygon);
    } else {
        alert("–î–ª—è –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –∑–∞–ø—Ä–µ—Ç–Ω–æ–π –∑–æ–Ω—ã –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –≤—ã–±—Ä–∞—Ç—å —Ö–æ—Ç—è –±—ã —Ç—Ä–∏ —Ç–æ—á–∫–∏.");
    }
    points = []; // –û—á–∏—â–∞–µ–º –º–∞—Å—Å–∏–≤ —Ç–æ—á–µ–∫ –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è –∑–æ–Ω—ã
}
document.getElementById('postroit').addEventListener('click', function(event) {
    event.preventDefault();
    buildRoute();
});

// –§—É–Ω–∫—Ü–∏—è –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –æ—Ä—Ç–æ–¥—Ä–æ–º–∏–∏ –∏ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è —Å –∑–æ–Ω–∞–º–∏ –∑–∞–ø—Ä–µ—Ç–∞
function buildRoute() {
    var startPoint = document.getElementById('start_point').value.split(',').map(Number).reverse();
    var endPoint = document.getElementById('end_point').value.split(',').map(Number).reverse();
    var numNodes = parseInt(document.getElementById('num_nodes').value);

    if (startPoint.length !== 2 || isNaN(startPoint[0]) || isNaN(startPoint[1])) {
        alert("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –Ω–∞—á–∞–ª—å–Ω–æ–π —Ç–æ—á–∫–∏ (—à–∏—Ä–æ—Ç–∞, –¥–æ–ª–≥–æ—Ç–∞).");
        return;
    }
    if (endPoint.length !== 2 || isNaN(endPoint[0]) || isNaN(endPoint[1])) {
        alert("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∫–æ–Ω–µ—á–Ω–æ–π —Ç–æ—á–∫–∏ (—à–∏—Ä–æ—Ç–∞, –¥–æ–ª–≥–æ—Ç–∞).");
        return;
    }
    if (isNaN(numNodes) || numNodes < 2) {
        alert("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–∑–ª–æ–≤ (–Ω–µ –º–µ–Ω–µ–µ 2).");
        return;
    }

    // –£–¥–∞–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –º–∞—Ä—à—Ä—É—Ç—ã
    removeRoutes();



    fetch('/orthodrome', {  // —Å–≤—è–∑—å —Å –±—ç–∫–µ–Ω–¥–æ–º
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            start_point: startPoint,
            end_point: endPoint,
            num_nodes: numNodes,
            orthodrome: isOrthodrome,
            restricted_areas: restrictedAreas.map(area => area.geometry.getCoordinates()[0]) // –ü–µ—Ä–µ–¥–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤—Å–µ—Ö –∑–æ–Ω –∑–∞–ø—Ä–µ—Ç–∞
        })
    })
    .then(response => response.json())
    .then(data => {
        const coords = data.coordinates.map(coord => [coord[0], coord[1]]);

        const routeLine = new ymaps.Polyline(coords, {
            balloonContent: '–ú–∞—Ä—à—Ä—É—Ç'
        }, {
            strokeColor: isOrthodrome ? 'rgb(155, 16, 17)' : 'rgb(0, 0, 255)',
            strokeWidth: 4
        });

        myMap.geoObjects.add(routeLine);
        routes.push(routeLine);
        myMap.setBounds(routeLine.geometry.getBounds());
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –º–∞—Ä—à—Ä—É—Ç –≤ KMZ
        //saveRouteAsKMZ(coords);  // –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –º–∞—Ä—à—Ä—É—Ç–∞ –≤ KMZ

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π –º–∞—Ä—à—Ä—É—Ç–∞ —Å –∑–æ–Ω–∞–º–∏ –∑–∞–ø—Ä–µ—Ç–∞
        checkIntersections(coords);  // –ó–¥–µ—Å—å –æ–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π
    })
    .catch(error => {
        console.error('–û—à–∏–±–∫–∞:', error);
    });
}

/////////////////////////////////////////////–ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –∫–Ω–æ–ø–∫–∏ –∫–∞—á–∞–µ—Ç—Å—è —Ñ–∞–π–ª –≤ KMZ///////////////////////////////////////////////////////////////

document.getElementById('downloadButton').addEventListener('click', function() {
    downloadKMZ();
});

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –º–∞—Ä—à—Ä—É—Ç–∞ –≤ KMZ
function downloadKMZ() {
    const routeCoords = routes[0].geometry.getCoordinates(); // –ü–æ–ª—É—á–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –º–∞—Ä—à—Ä—É—Ç–∞

    if (!routeCoords || routeCoords.length === 0) {
        alert("–ú–∞—Ä—à—Ä—É—Ç –Ω–µ –ø–æ—Å—Ç—Ä–æ–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ—Å—Ç—Ä–æ–π—Ç–µ –º–∞—Ä—à—Ä—É—Ç –ø–µ—Ä–µ–¥ —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ–º.");
        return;
    }

    fetch('/create_kmz', { // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –Ω–∞ —Å–µ—Ä–≤–µ—Ä –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è KMZ
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            coordinates: routeCoords
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.kmz_url) {
            // –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª
            const downloadLink = document.createElement('a');
            downloadLink.href = data.kmz_url;
            downloadLink.download = 'route.kmz';
            downloadLink.click();
        } else {
            alert('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –º–∞—Ä—à—Ä—É—Ç–∞.');
        }
    })
    .catch(error => {
        console.error('–û—à–∏–±–∫–∞:', error);
        alert('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –º–∞—Ä—à—Ä—É—Ç–∞.');
    });
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////

// –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –∏ –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏—è —Ç–æ—á–µ–∫ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è —Å–µ–≥–º–µ–Ω—Ç–∞ —Å –ø–æ–ª–∏–≥–æ–Ω–æ–º
function getIntersectionPoints(segment, polygon) {
    let intersectionPoints = [];

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–π –∫—Ä–∞–π –ø–æ–ª–∏–≥–æ–Ω–∞
    for (let i = 0; i < polygon.length - 1; i++) {
        const edge = [polygon[i], polygon[i + 1]];
        const intersection = findIntersection(segment, edge);

        if (intersection) {
            intersectionPoints.push(intersection);
        }
    }

    return intersectionPoints;
}


// –§—É–Ω–∫—Ü–∏—è –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è —Ç–æ—á–∫–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –¥–≤—É—Ö –æ—Ç—Ä–µ–∑–∫–æ–≤
function findIntersection(seg1, seg2) {
    const [p1, p2] = seg1;
    const [q1, q2] = seg2;

    // –í–µ–∫—Ç–æ—Ä–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
    const denominator = (q2[1] - q1[1]) * (p2[0] - p1[0]) - (q2[0] - q1[0]) * (p2[1] - p1[1]);

    if (Math.abs(denominator) < 1e-10) {
        return null; // –û—Ç—Ä–µ–∑–∫–∏ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã
    }

    const ua = ((q2[0] - q1[0]) * (p1[1] - q1[1]) - (q2[1] - q1[1]) * (p1[0] - q1[0])) / denominator;
    const ub = ((p2[0] - p1[0]) * (p1[1] - q1[1]) - (p2[1] - p1[1]) * (p1[0] - q1[0])) / denominator;

    // –£—Ç–æ—á–Ω–µ–Ω–∏–µ: –ø—Ä–æ–≤–µ—Ä—è–µ–º, –ª–µ–∂–∞—Ç –ª–∏ —Ç–æ—á–∫–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –≤–Ω—É—Ç—Ä–∏ –æ–±–æ–∏—Ö –æ—Ç—Ä–µ–∑–∫–æ–≤
    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–æ—á–∫—É –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
        return [
            p1[0] + ua * (p2[0] - p1[0]),
            p1[1] + ua * (p2[1] - p1[1])
        ];
    }

    return null; // –ù–µ—Ç –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
}

// –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –ª–∏–Ω–∏–∏ —Å –∑–æ–Ω–∞–º–∏ –∑–∞–ø—Ä–µ—Ç–∞
// –û–±—ä—è–≤–ª—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø–æ–∫–∞–∑–∞ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è
let intersectionAlertShown = false;

/////////////////////////////////////// –õ–ò–ù–ò–Ø –ü–ï–†–ï–°–ï–ß–ï–ù–ò–Ø –° –ó–û–ù–û–ô –ó–ê–ü–†–ï–¢–ê ///////////////////////////////////////

function checkIntersections(coords) {
    let hasIntersection = false;

   //  console.log("–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –º–∞—Ä—à—Ä—É—Ç–∞:", coords);

    // –ü—Ä–æ—Ö–æ–¥ –ø–æ –∫–∞–∂–¥–æ–º—É —Å–µ–≥–º–µ–Ω—Ç—É –º–∞—Ä—à—Ä—É—Ç–∞
    for (let i = 0; i < coords.length - 1; i++) {
        const segment = [coords[i], coords[i + 1]];

       // console.log("–°–µ–≥–º–µ–Ω—Ç –º–∞—Ä—à—Ä—É—Ç–∞:", segment); // –õ–æ–≥–∏—Ä—É–µ–º —Ç–µ–∫—É—â–∏–π —Å–µ–≥–º–µ–Ω—Ç

        restrictedAreas.forEach(area => {
            const areaCoords = area.geometry.getCoordinates()[0];
            const intersections = getIntersectionPoints(segment, areaCoords);

          //    console.log("–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∑–∞–ø—Ä–µ—Ç–Ω–æ–π –∑–æ–Ω—ã:", areaCoords);

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π
            if (intersections.length > 0 || isSegmentInPolygon(segment, areaCoords)) {
                hasIntersection = true;

            //    console.log("–ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è:", intersections); // –õ–æ–≥–∏—Ä—É–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è

                // –ï—Å–ª–∏ –æ—Ç—Ä–µ–∑–æ–∫ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ø–æ–ª–Ω–æ—Å—Ç—å—é –≤–Ω—É—Ç—Ä–∏ –∑–æ–Ω—ã –∑–∞–ø—Ä–µ—Ç–∞
                if (isSegmentInPolygon(segment, areaCoords)) {
                    const intersectionLine = new ymaps.Polyline([segment[0], segment[1]], {
                        balloonContent: '–û—Ç—Ä–µ–∑–æ–∫ –≤–Ω—É—Ç—Ä–∏ –∑–∞–ø—Ä–µ—Ç–Ω–æ–π –∑–æ–Ω—ã'
                    }, {
                        strokeColor: '#FFFFFF', // –ë–µ–ª—ã–π —Ü–≤–µ—Ç –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–∏—è –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
                        strokeWidth: 4
                    });

                    myMap.geoObjects.add(intersectionLine);
                    intersectionLines.push(intersectionLine);
                }
                // –ï—Å–ª–∏ –µ—Å—Ç—å –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è, –¥–æ–±–∞–≤–ª—è–µ–º –ª–∏–Ω–∏—é –æ—Ç —Ç–æ—á–∫–∏ –≤—Ö–æ–¥–∞ –¥–æ —Ç–æ—á–∫–∏ –≤—ã—Ö–æ–¥–∞ –∏–∑ –∑–æ–Ω—ã –∑–∞–ø—Ä–µ—Ç–∞
                else if (intersections.length > 0) {
                    let startPoint = intersections[0];
                    let endPoint = intersections[intersections.length - 1];

                  //  console.log("–ù–∞—á–∞–ª—å–Ω–∞—è —Ç–æ—á–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è:", startPoint);
                   // console.log("–ö–æ–Ω–µ—á–Ω–∞—è —Ç–æ—á–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è:", endPoint);

                    // –ï—Å–ª–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –≤ –Ω–∞—á–∞–ª–µ —Å–µ–≥–º–µ–Ω—Ç–∞ –∏–ª–∏ —Å–µ–≥–º–µ–Ω—Ç –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –≤ –∑–æ–Ω–µ
                    if (isPointInPolygon(segment[0], areaCoords)) {
                        startPoint = segment[0]; // –ù–∞—á–∞–ª—å–Ω–∞—è —Ç–æ—á–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è ‚Äî –ø–µ—Ä–≤–∞—è —Ç–æ—á–∫–∞ —Å–µ–≥–º–µ–Ω—Ç–∞
                    }

                    // –ï—Å–ª–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è –≤ –∫–æ–Ω—Ü–µ —Å–µ–≥–º–µ–Ω—Ç–∞ –∏–ª–∏ —Å–µ–≥–º–µ–Ω—Ç –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è –≤ –∑–æ–Ω–µ
                    if (isPointInPolygon(segment[1], areaCoords)) {
                        endPoint = segment[1]; // –ö–æ–Ω–µ—á–Ω–∞—è —Ç–æ—á–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è ‚Äî –ø–æ—Å–ª–µ–¥–Ω—è—è —Ç–æ—á–∫–∞ —Å–µ–≥–º–µ–Ω—Ç–∞
                    }

                    // –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –æ—Ç —Ç–æ—á–∫–∏ –≤—Ö–æ–¥–∞ –¥–æ —Ç–æ—á–∫–∏ –≤—ã—Ö–æ–¥–∞ –∏–∑ –∑–æ–Ω—ã –∑–∞–ø—Ä–µ—Ç–∞
                    const intersectionLine = new ymaps.Polyline([startPoint, endPoint], {
                        balloonContent: '–ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ —Å –∑–æ–Ω–æ–π –∑–∞–ø—Ä–µ—Ç–∞'
                    }, {
                        strokeColor: '#FFFFFF', // –ë–µ–ª—ã–π —Ü–≤–µ—Ç –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–∏—è –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
                        strokeWidth: 4
                    });

                    myMap.geoObjects.add(intersectionLine);
                    intersectionLines.push(intersectionLine);
                }

            }
        });
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // –ï—Å–ª–∏ –µ—Å—Ç—å –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ
    if (hasIntersection && !intersectionAlertShown) {
        alert("–ú–∞—Ä—à—Ä—É—Ç –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç –∑–∞–ø—Ä–µ—Ç–Ω—ã–µ –∑–æ–Ω—ã!");
        intersectionAlertShown = true;
    } else if (!hasIntersection) {
        intersectionAlertShown = false; // –°–±—Ä–æ—Å–∏—Ç—å –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ, –µ—Å–ª–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π –Ω–µ—Ç
    }
}



// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ä–∞–≤–µ–Ω—Å—Ç–≤–∞ —Ç–æ—á–µ–∫ (—Å —É—á–µ—Ç–æ–º –≤–æ–∑–º–æ–∂–Ω—ã—Ö –Ω–µ–∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–≥—Ä–µ—à–Ω–æ—Å—Ç–µ–π)
function arePointsEqual(point1, point2) {
    const [x1, y1] = point1;
    const [x2, y2] = point2;
    const epsilon = 0.00001; // –¢–æ—á–Ω–æ—Å—Ç—å —Å—Ä–∞–≤–Ω–µ–Ω–∏—è –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –æ—à–∏–±–æ–∫ —Å –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–æ–π
    return Math.abs(x1 - x2) < epsilon && Math.abs(y1 - y2) < epsilon;
}

// –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ —Å–µ–≥–º–µ–Ω—Ç –ø–æ–ª–Ω–æ—Å—Ç—å—é –≤–Ω—É—Ç—Ä–∏ –ø–æ–ª–∏–≥–æ–Ω–∞
function isSegmentInPolygon(segment, polygon) {
    const [p1, p2] = segment;
    return isPointInPolygon(p1, polygon) && isPointInPolygon(p2, polygon);
}

// –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ —Ç–æ—á–∫–∞ –≤–Ω—É—Ç—Ä–∏ –ø–æ–ª–∏–≥–æ–Ω–∞
function isPointInPolygon(point, polygon) {
    let x = point[0], y = point[1];
    let inside = false;

    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        let xi = polygon[i][0], yi = polygon[i][1];
        let xj = polygon[j][0], yj = polygon[j][1];

        let intersect = ((yi > y) !== (yj > y)) &&
            (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
    }

    return inside;
}




// –ü—Ä–æ–≤–µ—Ä–∫–∞, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ —Ç–æ—á–∫–∞ –Ω–∞ –æ—Ç—Ä–µ–∑–∫–µ
function isPointOnSegment(p1, p2, point) {
    const crossProduct = (point[1] - p1[1]) * (p2[0] - p1[0]) - (point[0] - p1[0]) * (p2[1] - p1[1]);

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ª–µ–∂–∏—Ç –ª–∏ —Ç–æ—á–∫–∞ –Ω–∞ –ª–∏–Ω–∏–∏ (crossProduct –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ä–∞–≤–µ–Ω –Ω—É–ª—é)
    if (Math.abs(crossProduct) > Number.EPSILON) {
        return false;
    }

    const dotProduct = (point[0] - p1[0]) * (p2[0] - p1[0]) + (point[1] - p1[1]) * (p2[1] - p1[1]);
    if (dotProduct < 0) {
        return false;
    }

    const squaredLengthBA = (p2[0] - p1[0]) * (p2[0] - p1[0]) + (p2[1] - p1[1]) * (p2[1] - p1[1]);
    if (dotProduct > squaredLengthBA) {
        return false;
    }

    return true;
}


// –§—É–Ω–∫—Ü–∏—è —É–¥–∞–ª–µ–Ω–∏—è –ª–∏–Ω–∏–π –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
function removeIntersectionLines() {
    intersectionLines.forEach(line => {
        myMap.geoObjects.remove(line);
    });
    intersectionLines = []; // –û—á–∏—â–∞–µ–º –º–∞—Å—Å–∏–≤ –ª–∏–Ω–∏–π –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
}




// –ü—Ä–æ–≤–µ—Ä–∫–∞, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ —Ç–æ—á–∫–∞ –Ω–∞ –æ—Ç—Ä–µ–∑–∫–µ
function isPointOnSegment(p1, p2, point) {
    const crossProduct = (point[1] - p1[1]) * (p2[0] - p1[0]) - (point[0] - p1[0]) * (p2[1] - p1[1]);
    if (Math.abs(crossProduct) > 1e-10) return false; // –ù–µ –ª–µ–∂–∏—Ç –Ω–∞ –ø—Ä—è–º–æ–π

    const dotProduct = (point[0] - p1[0]) * (p2[0] - p1[0]) + (point[1] - p1[1]) * (p2[1] - p1[1]);
    if (dotProduct < 0) return false; // –ó–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –æ—Ç—Ä–µ–∑–∫–∞

    const squaredLength = (p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2;
    return dotProduct <= squaredLength; // –ù–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ —Ç–æ—á–∫–∞ –Ω–∞ –æ—Ç—Ä–µ–∑–∫–µ
}





// –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –æ—Ç—Ä–µ–∑–∫–∞ —Å –ø–æ–ª–∏–≥–æ–Ω–æ–º
function isSegmentIntersectingPolygon(segment, polygon) {
    for (let i = 0; i < polygon.length - 1; i++) {
        const edge = [polygon[i], polygon[i + 1]];
        if (segmentsIntersect(segment, edge)) {
            return true; // –ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –Ω–∞–π–¥–µ–Ω–æ
        }
    }
    return false; // –ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
}

// –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –¥–≤—É—Ö –æ—Ç—Ä–µ–∑–∫–æ–≤
function segmentsIntersect(seg1, seg2) {
    const [p1, p2] = seg1;
    const [q1, q2] = seg2;

    // –í–µ–∫—Ç–æ—Ä–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
    const d1 = crossProduct(subtract(p2, p1), subtract(q1, p1));
    const d2 = crossProduct(subtract(p2, p1), subtract(q2, p1));
    const d3 = crossProduct(subtract(q2, q1), subtract(p1, q1));
    const d4 = crossProduct(subtract(q2, q1), subtract(p2, q1));

    return d1 * d2 < 0 && d3 * d4 < 0; // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Å—Ç–æ—Ä–æ–Ω—ã
}

// –§—É–Ω–∫—Ü–∏—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –≤–µ–∫—Ç–æ—Ä–Ω–æ–≥–æ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è
function crossProduct(v1, v2) {
    return v1[0] * v2[1] - v1[1] * v2[0];
}

// –§—É–Ω–∫—Ü–∏—è –≤—ã—á–∏—Ç–∞–Ω–∏—è –≤–µ–∫—Ç–æ—Ä–æ–≤
function subtract(v1, v2) {
    return [v1[0] - v2[0], v1[1] - v2[1]];
}

// –§—É–Ω–∫—Ü–∏—è —É–¥–∞–ª–µ–Ω–∏—è –º–∞—Ä—à—Ä—É—Ç–æ–≤ —Å –∫–∞—Ä—Ç—ã
function removeRoutes() {
    routes.forEach(route => {
        myMap.geoObjects.remove(route);
    });
    routes = []; // –û—á–∏—â–∞–µ–º –º–∞—Å—Å–∏–≤ –º–∞—Ä—à—Ä—É—Ç–æ–≤
}

// –§—É–Ω–∫—Ü–∏—è —Å–±—Ä–æ—Å–∞ –∫–∞—Ä—Ç—ã
function resetMap() {
    myMap.geoObjects.removeAll();
    startMarker = null;
    endMarker = null;
    restrictedAreas = [];
    routes = [];
    intersectionLine = null;
    points = []; // –û—á–∏—â–∞–µ–º –º–∞—Å—Å–∏–≤ —Ç–æ—á–µ–∫
}

        let routeCoords = []; // –ú–∞—Å—Å–∏–≤ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –º–∞—Ä—à—Ä—É—Ç–∞



// –í—ã–∑—ã–≤–∞–π—Ç–µ —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é, –∫–æ–≥–¥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–≤–µ—Ä—à–∞–µ—Ç —Ä–∏—Å–æ–≤–∞–Ω–∏–µ –º–∞—Ä—à—Ä—É—Ç–∞
function finalizeRoute() {
    sendRouteToBackend(routeCoords); // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –Ω–∞ –±—ç–∫–µ–Ω–¥
    // –ú–æ–∂–Ω–æ —Ç–∞–∫–∂–µ —Å–±—Ä–æ—Å–∏—Ç—å –º–∞—Å—Å–∏–≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
    routeCoords = [];
}

        function sendRouteToBackend(routeCoords) {
    fetch('/check_intersection', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ route: routeCoords }),
    })
    .then(response => response.json())
    .then(data => {
        if (data.intersections.length > 0) {
            displayIntersectionLines(data.intersections);
            alert("–ú–∞—Ä—à—Ä—É—Ç –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç –∑–æ–Ω—É –∑–∞–ø—Ä–µ—Ç–∞!");
        }
    })
    .catch((error) => {
        console.error('–û—à–∏–±–∫–∞:', error);
    });
}

function displayIntersectionLines(intersections) {
    if (intersectionLine) {
        myMap.geoObjects.remove(intersectionLine); // –£–¥–∞–ª—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â—É—é –ª–∏–Ω–∏—é
    }

    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π –≤ —Ñ–æ—Ä–º–∞—Ç –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–∞ –∫–∞—Ä—Ç–µ
    const intersectionSegments = intersections.flat().map(coords => {
        return [coords[1], coords[0]]; // –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ –Ω–∞ –ø–æ—Ä—è–¥–æ–∫ [—à–∏—Ä–æ—Ç–∞, –¥–æ–ª–≥–æ—Ç–∞]
    });

    // –°–æ–∑–¥–∞–µ–º –ª–∏–Ω–∏—é –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
    intersectionLine = new ymaps.Polyline(intersectionSegments, {
        balloonContent: '–ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ —Å –∑–æ–Ω–æ–π –∑–∞–ø—Ä–µ—Ç–∞'
    }, {
        strokeColor: '#FFFFFF', // –ö—Ä–∞—Å–Ω—ã–π —Ü–≤–µ—Ç –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–∏—è –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π
        strokeWidth: 3
    });

    myMap.geoObjects.add(intersectionLine); // –î–æ–±–∞–≤–ª—è–µ–º –ª–∏–Ω–∏—é –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –Ω–∞ –∫–∞—Ä—Ç—É
}

function drawIntersectionLine(coordinates) {
    const intersectionLine = new L.polyline(coordinates.map(coord => [coord[1], coord[0]]), {
        color: 'red', // –¶–≤–µ—Ç –ª–∏–Ω–∏–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
        weight: 2,
        dashArray: '5, 5' // –î–∞—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å—Ç–∏–ª—å –ª–∏–Ω–∏–∏
    }).addTo(map);
}

function drawIntersectionPoint(coordinate) {
    L.marker([coordinate[1], coordinate[0]], {icon: redMarker}).addTo(map);
}

// –ü–æ—Å–ª–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–ø—Ä–æ—Å–∞ –Ω–∞ —Å–æ–∑–¥–∞–Ω–∏–µ –æ—Ä—Ç–æ–¥—Ä–æ–º–∏–∏
fetch('/orthodrome', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({
        start_point: [lon1, lat1],
        end_point: [lon2, lat2],
        num_nodes: num_nodes,
        restricted_areas: [[ [x1, y1], [x2, y2], [x3, y3], [x4, y4] ]]
    })
})
.then(response => response.json())
.then(data => {
    if (data.error) {
        console.error(data.error);
        // –û—Ç–æ–±—Ä–∞–∑–∏—Ç–µ –ª–∏–Ω–∏–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
        if (data.intersections) {
            data.intersections.forEach(intersection => {
                // –ü—Ä–µ–¥–ø–æ–ª–æ–∂–∏–º, –≤—ã –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ API –¥–ª—è —Ä–∏—Å–æ–≤–∞–Ω–∏—è –Ω–∞ –∫–∞—Ä—Ç–µ
                drawIntersection(intersection); // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
            });
        }
    } else {
        // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –º–∞—Ä—à—Ä—É—Ç–∞
        drawRoute(data.coordinates); // –í–∞—à–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∏—Å–æ–≤–∞–Ω–∏—è –º–∞—Ä—à—Ä—É—Ç–∞
    }
})
.catch(error => console.error('–û—à–∏–±–∫–∞:', error));


  /////////////////////////////// –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å–∫–æ—Ä–æ—Å—Ç–∏ –∏ –≤—ã—Å–æ—Ç—ã –Ω–∞ –±–µ–∫–µ–Ω–¥ /////////////////////

document.getElementById('form').addEventListener('submit', function (event) {
    event.preventDefault();

    const speed = document.getElementById('speed').value;  // –ü–æ–ª—É—á–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏
    const altitude = document.getElementById('altitude').value;  // –ü–æ–ª—É—á–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –≤—ã—Å–æ—Ç—ã

    buildRoute(speed, altitude);  // –ü–µ—Ä–µ–¥–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–∫–æ—Ä–æ—Å—Ç–∏ –∏ –≤—ã—Å–æ—Ç—ã –≤ —Ñ—É–Ω–∫—Ü–∏—é –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –º–∞—Ä—à—Ä—É—Ç–∞


});
/////////////////////////////// –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å–∫–æ—Ä–æ—Å—Ç–∏ –∏ –≤—ã—Å–æ—Ç—ã –Ω–∞ –±–µ–∫–µ–Ω–¥ /////////////////////

/////////////////////////////// –æ—Ç–ø—Ä–∞–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –±–µ—Å–ø–∏–ª–æ—Ç–Ω–∏–∫ —á–µ—Ä–µ–∑ —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥ /////////////////////
document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('sendToDrone').addEventListener('click', function() {
        console.log("–ö–Ω–æ–ø–∫–∞ '–û—Ç–ø—Ä–∞–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –Ω–∞ –±–µ—Å–ø–∏–ª–æ—Ç–Ω–∏–∫' –Ω–∞–∂–∞—Ç–∞!");

        var speedInput = document.getElementById('speed').value;
        var altitudeInput = document.getElementById('altitude').value;
        console.log("–°–∫–æ—Ä–æ—Å—Ç—å:", speedInput, "–í—ã—Å–æ—Ç–∞:", altitudeInput);

        if (!speedInput || !altitudeInput || speedInput.trim() === "" || altitudeInput.trim() === "") {
            console.log("–û–¥–Ω–æ –∏–ª–∏ –æ–±–∞ –ø–æ–ª—è –ø—É—Å—Ç—ã–µ");
            alert("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏—è —Å–∫–æ—Ä–æ—Å—Ç–∏ –∏ –≤—ã—Å–æ—Ç—ã.");
            return;
        }

        var speed = parseFloat(speedInput);
        var altitude = parseFloat(altitudeInput);

        if (isNaN(speed) || isNaN(altitude)) {
            alert("–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ —á–∏—Å–ª–æ–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è —Å–∫–æ—Ä–æ—Å—Ç–∏ –∏ –≤—ã—Å–æ—Ç—ã.");
            return;
        }

        console.log("–û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –Ω–∞ —Å–µ—Ä–≤–µ—Ä:", { speed, altitude });

        fetch('/send_to_drone', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ speed: speed, altitude: altitude })
        })
        .then(response => {
            console.log("–û—Ç–≤–µ—Ç —Å–µ—Ä–≤–µ—Ä–∞:", response);
            return response.json();
        })
        .then(data => {
            console.log("–û—Ç–≤–µ—Ç –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞:", data);
            if (data.status) {
                alert("–î–∞–Ω–Ω—ã–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –Ω–∞ –±–µ—Å–ø–∏–ª–æ—Ç–Ω–∏–∫!");
            } else if (data.error) {
                alert("–û—à–∏–±–∫–∞: " + data.error);
            } else {
                alert("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –æ—Ç–≤–µ—Ç –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞.");
            }
        })
        .catch(error => {
            console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –¥–∞–Ω–Ω—ã—Ö:', error);
            alert("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ —Å–µ—Ä–≤–µ—Ä.");
        });
    });
});


/////////////////////////////// –æ—Ç–ø—Ä–∞–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –±–µ—Å–ø–∏–ª–æ—Ç–Ω–∏–∫ —á–µ—Ä–µ–∑ —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥ /////////////////////
/////////////////////////////// –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω–Ω–µ–∫—Ç–∞ –∫ –±–µ—Å–ø–∏–ª–æ—Ç–Ω–∏–∫—É  /////////////////////


/////////////////////////////// –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω–Ω–µ–∫—Ç–∞ –∫ –±–µ—Å–ø–∏–ª–æ—Ç–Ω–∏–∫—É  /////////////////////

    document.addEventListener('DOMContentLoaded', function() {
        document.getElementById('connectDrone').addEventListener('click', function() {
            console.log("–ö–Ω–æ–ø–∫–∞ –Ω–∞–∂–∞—Ç–∞!");
            fetch('/connect', { method: 'GET' })
                .then(response => response.json())
                .then(data => alert(data.status || data.error))
                .catch(error => alert("–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–µ—Å–ø–∏–ª–æ—Ç–Ω–∏–∫—É: " + error));
        });
    });



</script>

</body>
</html>